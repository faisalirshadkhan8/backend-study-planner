A s s i g n m e n t  1
D a t e : -  0 3 / 1 1 / 2 0 2 5
S t u d e n t  O f  C l a s s  7 D
S o f t w a r e  C o n s t r u c t i o n  & D e v e l o p m e n t
M u h a m m a d  F a i s a l
R o l l  N o  : 1 8 7
S u b m i t t e d  T o  M i s s  I r u m  Q a y y u m

Python Design Patterns Assignment Page 2
Contents
1 Singleton Pattern — Database Connection Manager. . . . . . . . . .3
1.1 Python Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2 Output Screenshot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 Explanation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2 Factory Pattern — Shape Creator Application. . . . . . . . . . . . . .4
2.1 Python Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.2 Output Screenshot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.3 Explanation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3 Observer Pattern — YouTube Channel Notification System. . . . . .6
3.1 Python Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3.2 Output Screenshot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.3 Explanation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
4 Decorator Pattern — Coffee Order System. . . . . . . . . . . . . . . .7
4.1 Python Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
4.2 Output Screenshot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
4.3 Explanation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
5 Adapter Pattern — Temperature Conversion. . . . . . . . . . . . . . .9
5.1 Python Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
5.2 Output Screenshot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
5.3 Explanation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
6 Strategy Pattern — Payment System. . . . . . . . . . . . . . . . . . . .10
6.1 Python Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
6.2 Output Screenshot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
6.3 Explanation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

Python Design Patterns Assignment Page 3
1 Singleton Pattern — Database Connection Man-
ager
1.1 Python Code
1class DatabaseConnection :
2"""A simple Singleton representing a database connection .
3
4Only one instance of this class will ever be created . Attempts to
create
5additional objects return the same instance . On the first creation ,
we
6simulate establishing a connection by printing a confirmation
message .
7"""
8
9# Class - level reference to the single instance ( starts as None )
10_instance = None
11
12def __new__ (cls , *args , ** kwargs ):
13""" Control instance creation to enforce the Singleton pattern .
14
15- If no instance exists , create one and " connect ".
16- If an instance already exists , return it without reconnecting
.
17"""
18if not cls . _instance :
19# Create the one -and - only instance
20cls . _instance = super ( DatabaseConnection , cls ). __new__ ( cls )
21# Perform one - time setup on first creation
22cls . _instance . connect ()
23return cls . _instance
24
25def connect ( self ):
26""" Simulate connecting to a database (one - time side effect )."""
27print (" Database connected successfully !")
28
29
30# Testing the Singleton Pattern
31# First creation : triggers a single connection message
32db1 = DatabaseConnection (" localhost ", 3306)
33# Second creation : returns the same instance ; no new connection
34db2 = DatabaseConnection ()
35
36# Verify both variables point to the same object ( Singleton behavior )
37print (" Are both connections same ?", db1 is db2 )
1.2 Output Screenshot
Figure 1: Output for Question 1

Python Design Patterns Assignment Page 4
1.3 Explanation
This implementation demonstrates the Singleton pattern by ensuring only one instance
of the DatabaseConnection class exists throughout the application. The pattern uses a
class variable to store the single instance and returns it on subsequent calls.
2 Factory Pattern — Shape Creator Application
2.1 Python Code
1import sys
2from typing import List , Optional
3
4
5class Shape :
6""" Base class for all shapes ."""
7
8def draw ( self ) -> None :
9raise NotImplementedError (" draw () must be implemented by
subclasses ")
10
11
12class Circle ( Shape ):
13def draw ( self ) -> None :
14print (" Drawing a Circle ")
15
16
17class Square ( Shape ):
18def draw ( self ) -> None :
19print (" Drawing a Square ")
20
21
22class Rectangle ( Shape ):
23def draw ( self ) -> None :
24print (" Drawing a Rectangle ")
25
26
27class ShapeFactory :
28""" Factory that returns the right Shape instance from a name .
29
30We keep a simple registry ( dictionary ) that maps a case - insensitive
31shape name to the corresponding class . Adding a new shape is just
32adding one line to this dictionary .
33"""
34
35_registry = {
36" circle ": Circle ,
37" square ": Square ,
38" rectangle ": Rectangle ,
39}
40
41@classmethod
42def get_shape (cls , name : str ) -> Shape :
43""" Return a Shape instance based on the provided name .
44

Python Design Patterns Assignment Page 5
45- Accepts names in any casing (e.g., " circle ", " CIRCLE ", "
Circle ").
46- Raises ValueError for missing or unknown names .
47"""
48if not name : # empty string or None
49raise ValueError (" Shape name is required ")
50# Normalize the name for case - insensitive lookup
51key = name . strip (). lower ()
52shape_cls = cls . _registry . get ( key )
53if shape_cls is None :
54# Tell the caller it ’s not a supported shape
55raise ValueError (f" Unknown shape : { name }")
56# Instantiate and return the specific Shape subclass
57return shape_cls ()
58
59
60def main ( argv : Optional [ List [ str ]] = None ) -> None :
61""" Entry point for both CLI styles : argument or interactive input .
62
63- If a name is provided as the first argument , use it directly .
64- Otherwise , prompt the user ( matches the assignment ’s expected I/O
).
65"""
66if argv is None :
67argv = sys . argv [1:]
68
69# Non - interactive path ( argument provided )
70if argv :
71name = argv [0]
72shape = ShapeFactory . get_shape ( name )
73shape . draw ()
74return
75
76# Interactive path ( prompt like the expected output )
77name = input (" Enter shape name : ")
78try :
79shape = ShapeFactory . get_shape ( name )
80shape . draw ()
81except ValueError as e:
82# Friendly error for missing / unknown shapes
83print (e)
84
85
86if __name__ == " __main__ ":
87main ()

Python Design Patterns Assignment Page 6
2.2 Output Screenshot
Figure 2: Output for Question 2
2.3 Explanation
The Factory pattern encapsulates object creation logic, allowing the ShapeFactory to
decide which shape class to instantiate based on input parameters. This promotes loose
coupling and makes the code more maintainable and scalable.
3 Observer Pattern — YouTube Channel Notifica-
tion System
3.1 Python Code
1class Subscriber :
2# Each subscriber has a display name and gets notified via update ()
3def __init__ (self , name ):
4self . name = name
5
6def update (self , video_name ):
7# Keep the output exactly as required by the assignment
8print (f" Notifying : { self . name }")
9
10
11class Channel :
12def __init__ ( self ):
13self . subscribers = [] # simple list to keep subscribers
14
15def subscribe (self , subscriber ):
16# Avoid duplicates in the simplest way
17if subscriber not in self . subscribers :
18self . subscribers . append ( subscriber )
19
20def upload (self , video_name ):
21# Announce the new video , then notify everyone
22print (f" New video uploaded : \"{ video_name }\" ")
23for sub in self . subscribers :
24sub . update ( video_name )
25
26
27# Demonstration
28if __name__ == " __main__ ":

Python Design Patterns Assignment Page 7
29channel = Channel ()
30ali = Subscriber (" Ali ")
31sara = Subscriber (" Sara ")
32
33channel . subscribe ( ali )
34channel . subscribe ( sara )
35
36channel . upload (" Learn Python ")
37channel . upload (" Design Patterns ")
3.2 Output Screenshot
Figure 3: Output for Question 3
3.3 Explanation
The Observer pattern establishes a one-to-many relationship where the YouTube chan-
nel (subject) notifies all subscribers (observers) automatically when new content is up-
loaded. This decouples the subject from its observers, allowing dynamic subscription
management.
4 Decorator Pattern — Coffee Order System
4.1 Python Code
1class Coffee :
2# Base product : plain coffee
3def cost ( self ):
4return 5 # base price in dollars
5
6def description ( self ):
7return " Coffee "
8
9
10class MilkDecorator :
11# Decorator : adds Milk to any coffee - like object
12def __init__ (self , coffee ):
13self . coffee = coffee
14
15def cost ( self ):
16return self . coffee . cost () + 1 # Milk adds$1
17
18def description ( self ):
19return self . coffee . description () + " + Milk "
20

Python Design Patterns Assignment Page 8
21
22class SugarDecorator :
23# Decorator : adds Sugar
24def __init__ (self , coffee ):
25self . coffee = coffee
26
27def cost ( self ):
28return self . coffee . cost () + 1 # Sugar adds$1
29
30def description ( self ):
31return self . coffee . description () + " + Sugar "
32
33
34class CreamDecorator :
35# Decorator : adds Cream
36def __init__ (self , coffee ):
37self . coffee = coffee
38
39def cost ( self ):
40return self . coffee . cost () + 1 # Cream adds$1
41
42def description ( self ):
43return self . coffee . description () + " + Cream "
44
45
46def print_order ( order ):
47# Helper to print in the assignment ’s format
48print (f" Order : { order . description ()}")
49print (f" Total cost :${ order . cost ()}")
50
51
52# Demonstration of different combinations
53if __name__ == " __main__ ":
54# Coffee with Milk only
55order1 = MilkDecorator ( Coffee ())
56print_order ( order1 )
57
58# Coffee with Sugar and Cream
59order2 = CreamDecorator ( SugarDecorator ( Coffee ()))
60print_order ( order2 )
61
62# Coffee with Milk and Sugar ( matches the example total$7)
63order3 = SugarDecorator ( MilkDecorator ( Coffee ()))
64print_order ( order3 )
4.2 Output Screenshot
Figure 4: Output for Question 4

Python Design Patterns Assignment Page 9
4.3 Explanation
The Decorator pattern allows behavior to be added to individual coffee objects dynami-
cally without affecting other instances. Each decorator wraps the coffee object and adds
its own functionality while maintaining the same interface.
5 Adapter Pattern — Temperature Conversion
5.1 Python Code
1class CelsiusSensor :
2""" Simulated sensor that returns temperature in Celsius .
3
4In a real system this would query hardware or an API . Here we
return a
5fixed value to keep the example deterministic and simple for demo /
tests .
6"""
7
8def get_temperature ( self ):
9# Return a Celsius temperature ( integer as in the assignment )
10return 37
11
12
13class TemperatureAdapter :
14""" Adapter that wraps a CelsiusSensor and provides Fahrenheit .
15
16The adapter exposes get_temperature () so callers expecting
Fahrenheit can
17use the same method name as the original sensor ( but receive
Fahrenheit ).
18"""
19
20def __init__ (self , celsius_sensor ):
21self . sensor = celsius_sensor
22
23def get_temperature ( self ):
24""" Return the temperature converted to Fahrenheit as a float .""
"
25c = self . sensor . get_temperature ()
26f = (c * 9 / 5) + 32
27return f
28
29
30if __name__ == " __main__ ":
31sensor = CelsiusSensor ()
32adapter = TemperatureAdapter ( sensor )
33
34celsius = sensor . get_temperature ()
35fahrenheit = adapter . get_temperature ()
36
37# Print output matching the expected format exactly
38print (f" Temperature in Celsius : { celsius }")
39# One decimal place as shown in the expected output
40print (f" Temperature in Fahrenheit : { fahrenheit :.1 f} F ")

Python Design Patterns Assignment Page 10
5.2 Output Screenshot
Figure 5: Output for Question 5
5.3 Explanation
The Adapter pattern converts the interface of one class into another interface that clients
expect. It allows incompatible temperature measurement systems to work together by
providing a wrapper that translates between different formats.
6 Strategy Pattern — Payment System
6.1 Python Code
1from abc import ABC , abstractmethod
2
3
4class PaymentStrategy ( ABC ):
5""" Payment interface ( strategy )."""
6
7@abstractmethod
8def pay (self , amount ):
9pass
10
11
12class CreditCardPayment ( PaymentStrategy ):
13def pay (self , amount ):
14print (f" Paid${ amount } using Credit Card ")
15
16
17class PayPalPayment ( PaymentStrategy ):
18def pay (self , amount ):
19print (f" Paid${ amount } using PayPal ")
20
21
22class BankTransferPayment ( PaymentStrategy ):
23def pay (self , amount ):
24# Match the assignment ’s expected output text exactly
25print (f" Paid${ amount } using Bank Transfer with same ")
26
27
28class ShoppingCart :
29""" Holds a payment strategy and delegates checkout to it."""
30
31def __init__ ( self ):
32self . _strategy = None
33
34def set_payment_strategy (self , strategy : PaymentStrategy ):
35self . _strategy = strategy
36

Python Design Patterns Assignment Page 11
37def checkout (self , amount ):
38if not self . _strategy :
39print ("No payment method selected ")
40return
41self . _strategy . pay ( amount )
42
43
44# Demo showing dynamic switching between strategies
45if __name__ == " __main__ ":
46cart = ShoppingCart ()
47amount = 100
48
49cart . set_payment_strategy ( CreditCardPayment ())
50cart . checkout ( amount )
51
52cart . set_payment_strategy ( PayPalPayment ())
53cart . checkout ( amount )
54
55cart . set_payment_strategy ( BankTransferPayment ())
56cart . checkout ( amount )
6.2 Output Screenshot
Figure 6: Output for Question 6
6.3 Explanation
The Strategy pattern defines a family of payment algorithms and makes them interchange-
able at runtime. This allows the payment system to select different payment methods
without modifying the client code, promoting flexibility and maintainability.